<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Lab exercise: Voting booth</title>
		<link href="../labGuide.css" type="text/css" rel="stylesheet">
		<style>
			pre {
				border: 1px solid black;
				padding: 3px;
			}

			.prompt {
				color: white;
				background-color: black;
				border: 1px solid gray;
			}
		</style>
	</head>

	<body>
		<div id="page">
			<h1>Lab exercise: Voting booth (forms, GET, POST, and node.js)</h1>

			<p>In this lab, you get experience with HTTP GET and POST requests.  We will use <em>forms</em> to send requests from the client side and <em>Node.js</em> to receive them on the server side.</p>

			<h2>Preliminaries</h2>

			<p>Install Node.js:</p>
			<ul>
				<li>Download it from the <a href="http://nodejs.org">Node.js website</a> (the &quot;Recommended For Most Users&quot; version).</li>
				<li>Install it.</li>
			</ul>

			<h2>Basic structure of a Node.js server</h2>

			<p>First, we install the &quot;Express&quot; module for Node.  Express makes certain tasks easier for us.  On the command prompt or Windows PowerShell (in the same folder where your code files will be), we use <code>npm</code> to install it:</p>

<pre class="prompt">npm install express</pre>

			<p>That should make a <code>node_modules</code> folder containing a ton of sub-folders with files inside.</p>

			<p>Now we add code to load up the express module and to create an instance of it for our server.  Put this in your <code>server.js</code> file:</p>

<pre>var express = require("express");
var server = express();</pre>

			<p>To specify a function to be executed when we receive a GET request at <code>/numberOfCandidates</code> we do something like this:</p>

<pre>server.get("/numberOfCandidates", function(req, res) {
	res.set("Content-Type", "text/plain"); //Tells the browser what kind of content this will be
	res.set("Cache-Control", "no-cache");  //Tells the browser: "don't use a cached response; ask the server every time".
	res.write("My estimate is " + 100*Math.random() ); //sends this text as a response to the client
	res.end(); //done with the response to the client
});</pre>

			<p>Finally, we add some code at the end of your file to activate the server on port 80 (which is standard for HTTP):</p>

<pre>server.listen(80, function() {
	console.log("Server is now running on port 80."); //This callback happens once the server is ready.
});</pre>

			<p>Run <code class="prompt">node server.js</code> at the command prompt.  We can do a GET request by simply visiting <a href="http://127.0.0.1/numberOfCandidates">http://127.0.0.1/numberOfCandidates</a> which should show something like &quot;My estimate is 86.68609770255145.&quot;.</p>

			<h2>Headers</h2>

			<p>Here we'll go through the two HTTP headers I provided in the code above.</p>

			<h3>Cache-Control</h3>

			<p>Web browsers keep a cache of files.  These are re-used in order to save on bandwidth and to speed loading times.  When a browser makes a GET request for some file (or in our case, to run a script), the server typically sends back header information indicating if the response should be <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching">cached</a>, and for how long (using the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">Cache-Control HTTP header</a>), among other possible options.  Try changing <code>no-cache</code> to <code>max-age=10</code> in your server.js file.</p>

			<p>Remember that after you modify and save <code>server.js</code>, you must take down your server by using <code>ctrl-c</code> on the command line and then restart it (up-arrow and enter).</p>

			<p>If you visit <a href="http://127.0.0.1/numberOfCandidates">http://127.0.0.1/numberOfCandidates</a> and hit refresh, the browser will probably show you a fresh random number each time.  But if you close the tab and paste the URL in again, expect to see the same number until the cache expires after 10 seconds.</p>

			<p>Switch it back to <code>no-cache</code> because we will want an up-to-date response from the server every time.</p>

			<h3>Content-Type</h3>

			<p>The server sends the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type">Content-Type HTTP header</a> so that the client knows what kind of file is coming back at it.  Some examples are <code>text/plain</code>, <code>image/png</code> and <code>video/mp4</code>.  If you are feeling adventurous, try setting it to <code>text/html</code> and have your server script send HTML back to the client instead of plain text.</p>

			<h2>Statically served files</h2>

			<p>We will want an <code>index.html</code> as part of the website.  To serve up &quot;plain old&quot; files (such as .html, jpg, .png, .txt, etc.), we use the &quot;static&quot; middleware.  Put the following line of code <em>just before</em> the call to <code>server.listen(80, ...);</code></p>

<pre>server.use(express.static("./pub"));</pre>

			<p>The order here matters (though not really for this lab).  We want to check for the URL <code>/numberOfCandidates</code> before we go out to the hard drive to check for files, so that our script would take precedence if some file happened to be named <code>numberOfCandidates</code> in our <code>pub</code> directory.  The middleware will be used in the order in which we call <code>use()</code>, <code>get()</code>, or <code>post()</code>.</p>

			<p>Put an <code>index.html</code> file into a subdirectory named <code>pub</code>.  Have it contain a form that points to your script; something like this will do (the submit button activates the server-side script and shows the response from the server as a new page):</p>

<pre>    &lt;form action=&quot;/numberOfCandidates&quot; method=&quot;get&quot;&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Get candidate count&quot;&gt;
    &lt;/form&gt;</pre>

			<p>Now visiting <a href="http://127.0.0.1">http://127.0.0.1</a> should show your html page, and you should be able to use your form to activate your node.js script.  <strong>Remember:</strong> always access the script by going to 127.0.0.1 - not double clicking the file, because it needs to communicate with your web server.  It knows which server to talk to based upon the origin, which is just the filesystem if you double-click the html file.  But 127.0.0.1 points to the web server running on your local machine, which is what you need.</p>

			<h2>&quot;Safe&quot; methods</h2>

			<p>GET is known as a <em>safe</em> HTTP method.  By <em>safe</em> we mean, &quot;safe to call without triggering side-effects or state changes on the server&quot;.  So when you write the server-side code for a GET, you should keep it to read-only operations.  It's ok to have the server keep a log of GET requests, but don't use a GET to modify the server's state (such as recording someone's vote) or cause side effects (such as submitting someone's e-commerce order), because browsers and web-crawlers are written with the understanding that it is <em>safe</em> to call a GET without triggering such side-effects.</p>
			<p>Consider the ramifications on our voting web app if we used a GET to submit votes, but then:</p>
			<ul>
				<li>A browser resubmitted our &quot;vote GET&quot; due to a communication error - and it got received by the server twice</li>
				<li>A web crawler keeps submitting our &quot;vote GET&quot; each time it visits the page</li>
				<li>A browser pre-fetches our &quot;vote GET&quot;</li>
			</ul>

			<!--
			<p>The GET method should be used to access resources that are <a href="https://developer.mozilla.org/en-US/docs/Glossary/Idempotent">idempotent</a>.  Basically, after the first request for a given resource, subsequent requests for it should not affect the <em>internal state</em> of the server - at least as far as the client can observe.  For example, it's ok to have the server keep a log of GET requests, but don't use a GET to record someone's vote, because multiple vote calls result in the variable incrementing multiple times.  To put it simply: nothing bad should happen if the browser makes the same GET request two or three times in a row instead of just once (say, because of some network failure).</p>
			-->

			<p>For recording votes, we will use POST instead.</p>

			<h2>Receiving a POST on the server side</h2>

			<p>In your server.js, let's implement a simple vote counter.  Put in the following code just before the <code>server.get(...)</code> part:</p>

<pre><code>let voteTotals = {}; //empty object

server.post("/vote", function(req, res) {
	//Establish the variable for this candidate, if needed, then increment their total.
	if (!voteTotals[req.body.candidate]) voteTotals[req.body.candidate] = 0;
	voteTotals[req.body.candidate]++;

	//Print out all the candidates' totals.
	for(person in voteTotals) {
		res.write(person + " has " + voteTotals[person]+"\n");
	}
	res.end();
});</code></pre>

<p>Notice that the structure is the same, except we are using <code>post</code> instead of <code>get</code> and using <code>/vote</code> instead of <code>/numberOfCandidates</code>.  We also left off the headers because text/plain is the default and POST should never be cached. In order for this code to run, we are going to need another module.  After the line that says <code>var server = express();</code> add in:</p>

<pre>bodyParser = require("body-parser");
server.use(bodyParser.urlencoded({extended: true}));</pre>

			<p>Normally you would install it using <code class="prompt">npm install body-parser</code> on the command prompt, but it is actually included already from installing express.</p>

			<p>It looks like we are using the <code>voteTotals</code> object as an associative array (i.e. indexed by strings instead of integers).  That's basically what's happening, although it is worth noting that each candidate name is actually being established as a property (instance variable) of the <code>voteTotals</code> object.</p>

			<p>We are using <code>req.body.candidate</code> because we will name the parameter <code>candidate</code> in our HTML.</p>

			<p>This code updates the count for the given candidate (named in the client's POST request), and then the vote totals for all candidates are sent back to the client.  POST is the natural choice for operations that modify internal server state, such as this one.</p>

			<p>If you try visiting <a href="http://127.0.0.1/vote">http://127.0.0.1/vote</a> directly it will fail, because you are issuing a GET rather than the POST that the server is expecting at <code>127.0.0.1/vote</code>.  We will use a form to make the POST request.</p>

			<h2>Submitting a POST from the client side using a form</h2>

			<p>Write another HTML form with a submit button, but this time use <code>method=&quot;post&quot;</code> and <code>action=&quot;/vote&quot;</code> to match what we put in on the server-side.  An <code>&lt;input&gt;</code> element's <code>name</code> attribute specifies the name of the variable that is sent to the server, so you will want something like this nested inside your form:</p>

<pre><code>&lt;label for="person">Person to vote for:&lt;/label&gt;
&lt;input type="text" id="person" name="candidate"&gt;</code></pre>

			<p>Note that <code>name="candidate"</code> matches the <code>req.body.candidate</code> on the server side.  If you submit a name with your form it should show you the vote totals so far.</p>

			<p>Remember to restart your node.js server on the command prompt whenever you make a change to server.js.  There are ways to automate this process (most notably <em>nodemon</em> which can be installed with npm).</p>

			<h2>Now run with it</h2>

			<p>Now that you have a basic voting system, build it up.  Put in the following features:</p>
			<ul>
				<li>As part of the server's response in <code>/vote</code>, have it print out which candidate they just voted for.</li>
				<li>Have it actually report the number of candidates instead of a random number.  <strong>Hint:</strong> Use a &quot;for...in&quot; loop to count the number of properties of <code>voteTotals</code>.  Be sure that you call <code>res.write()</code> with a <em>string</em> argument, not a number.</li>
				<li>Write a form and the server-side code for a GET that reports the <em>total</em> number of votes that have come in (all candidates summed together).</li>
				<li>Add a form where you type in a password to reset the voting system.  Use <code>&lt;input type="password"&gt;</code> to hide the text.  <strong>NOTE: using the password input does not make it secure.  At the very least, you would need to have https instead of http.</strong></li>
				<li>Add a form that uses a GET to retrieve the vote total for whatever candidate is specified in an input text.  Since you are using a GET instead of a POST, you will need to use <code>req.query.candidate</code> instead of <code>req.body.candidate</code> on the server side.  Note that the parameter and value will be visible in the browser's URL when you submit it, like this: <code>http://127.0.0.1/vote?candidate=me</code></li>
			</ul>


			<h2>Get credit on it</h2>

			<p>Show me your work when you are done.</p>

<!--
			<h2>Challenge</h2>

			<p>If that was too easy, try building in different controls for different actions.  Perhaps the web form has 3 different buttons for candidates and then a write-in option?  How about moving the vote-total view to a different button, and have that one require a password to access it (note: we aren't using https, so the password would be readable by anyone &quot;sniffing packets&quot;).</p>

			<h2>Other features</h2>

			<h3>Content-Type</h3>

			<p>Currently, your Node.js script is producing a response with the <code>text/plain</code> content type, so if you try to style your message back to the client with HTML elements such as &lt;p&gt; and &lt;em&gt;, they will be displayed as plain text instead of being interpreted as HTML on the client side.  In order to tell the client that your content should be interpreted as HTML, you can put the following command in before you do any other calls to the <code>res</code> object:</p>

<pre>res.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);</pre>

			<h3>A template engine</h3>

			<p>The approach of hard-coding an HTML response directly using <code>res.write()</code> doesn't scale well.  Another approach is to use a template engine such as EJS (&quot;Embedded JavaScript Templates&quot;).  Start with an install in your working folder:</p>

<pre class="prompt">npm install ejs</pre>
-->
			<p></p>

		</div>
	</body>
</html>
